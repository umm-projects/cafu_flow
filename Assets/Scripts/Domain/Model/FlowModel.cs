using System.Collections.Generic;
using CAFU.Core.Domain.Model;
using CAFU.Flow.Utility;
using UnityEngine;

namespace CAFU.Flow.Domain.Model
{
    public class FlowModel : IModel
    {
        /// <summary>
        /// Start time of flow. unit is seconds.
        /// </summary>
        public float Start { get; private set; }

        /// <summary>
        /// End time of flow. unit is seconds. The value less than 0 means not specify the end time.
        /// </summary>
        public float End { get; private set; }

        /// <summary>
        /// Interval time of flow emitting items. unit is seconds.
        /// </summary>
        public float IntervalTime { get; private set; }

        /// <summary>
        /// Random diviation time of interval time. unit is seconds.
        /// </summary>
        public float IntervalDivationTime { get; private set; }

        /// <summary>
        /// The number of emitting items in each interval.
        /// </summary>
        public int Units { get; private set; }

        /// <summary>
        /// Lotting items by specified weights.
        /// e.g. [{id: 1, weight: 9}, {id: 2, weight: 1}] then items of id:1 would be spawn with 90%.
        /// </summary>
        public WeightedArray<int> LotteryWeightArray { get; private set; }

        /// <summary>
        /// The number of generated items
        /// </summary>
        public int GeneratedCount { get; private set; }

        protected IList<KeyValuePair<int, float>> emitList;

        public FlowModel(
            float start,
            float end,
            float intervalTime,
            float intervalDivationTime,
            int units,
            WeightedArray<int> lotteryWeightArray
        )
        {
            this.Start = start;
            this.End = end;
            this.IntervalTime = intervalTime;
            this.IntervalDivationTime = intervalDivationTime;
            this.Units = units;
            this.LotteryWeightArray = lotteryWeightArray;
            this.GeneratedCount = 0;
            this.emitList = new List<KeyValuePair<int, float>>();
        }

        public void Reset()
        {
            this.GeneratedCount = 0;
            this.emitList.Clear();
        }

        public bool IsFinished(float time)
        {
            return time >= this.End;
        }

        public void GenerateItems(float time)
        {
            var expectedIntervalCount = this.GeneratedCount / this.Units;
            var generationTime = (expectedIntervalCount - 1) * this.IntervalTime + this.Start;

            if (time >= generationTime)
            {
                this.GenerateItemsOnIntervalCount(expectedIntervalCount);
            }
        }

        private void GenerateItemsOnIntervalCount(int intervalCount)
        {
            var baseTime = intervalCount * this.IntervalTime + this.Start;

            for (var i = 0; i < this.Units; i++)
            {
                var time = baseTime + this.GetRandomDivationTime();

                if (this.IsRangeSafeTime(time))
                {
                    var id = this.Lot();
                    this.emitList.Add(new KeyValuePair<int, float>(id, time));
                    this.GeneratedCount++;
                }
            }
        }

        /// <summary>
        /// Emit items which exceeds time.
        /// Items should be generated by GenerateIntervalItems before calling this method.
        /// </summary>
        /// <param name="time"></param>
        /// <returns></returns>
        public IEnumerable<int> EmitItems(float time)
        {
            var i = 0;
            var emitCount = 0;

            while (emitCount < this.Units && i < this.emitList.Count)
            {
                var item = this.emitList[i];

                if (item.Value <= time)
                {
                    this.emitList.RemoveAt(i);
                    yield return item.Key;
                    emitCount++;
                }
                else
                {
                    i++;
                }
            }
        }

        private bool IsRangeSafeTime(float time)
        {
            return this.Start <= time && time <= this.End;
        }

        protected int Lot()
        {
            return this.LotteryWeightArray.Lot();
        }

        protected float GetRandomDivationTime()
        {
            return Random.Range(-1f, 1f) * this.IntervalDivationTime;
        }
    }
}